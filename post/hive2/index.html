<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.69.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>数据仓库Hive_基本操作&nbsp;&ndash;&nbsp;YHFeio</title><link rel="stylesheet" href="/css/core.min.7a6dedeee7291c9daf16368afd3f5958f3793b2e6f9fa92597ff1df00f09a979724933f1b5bcf4264af992bb6fbee89c.css" integrity="sha384-em3t7ucpHJ2vFjaK/T9ZWPN5Oy5vn6kll/8d8A8JqXlySTPxtbz0Jkr5krtvvuic"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="数据仓库Hive_基本操作" /><body>
    <div class="base-body"><section id="header" class="site header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/logo.png" alt /><span class="site name">YHFeio</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about/">About</a></nav></div></span></div><div class="site slogan"><span class="title">Nice Things</span></div></section><div id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">数据仓库Hive_基本操作</h1><p class="article date">2020-05-02</p></section><article class="article markdown-body"><h1 id="数据仓库hive2">数据仓库Hive（2）</h1>
<p>官方文档中的<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual"target="_blank">language manual</a></p>
<ul>
<li>DDL（Data Definition Language，数据定义语言） 用来创建或者删除存储数据用的数据库以及数据库中的表等对象。CREATE、DROP、ALTER。</li>
<li>DML（Data Manipulation Language，数据操纵语言） 用来查询或者变更表中的记录，SELECT, INSERT, UPDATE, DELETE。</li>
<li>DCL（Data Control Language，数据控制语言） 用来确认或者取消对数据库中的数据进行的变更。以对RDBMS 的用户是否有权限操作数据库中的对象（数据库表等）进行设定，COMMIT, ROLLBACK, GRANT,REVOKE。</li>
</ul>
<h2 id="ddl操作">DDL操作</h2>
<h3 id="库操作">库操作</h3>
<p><strong>创建库</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="p">(</span><span class="k">DATABASE</span><span class="o">|</span><span class="k">SCHEMA</span><span class="p">)</span> <span class="p">[</span><span class="k">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span><span class="p">]</span> <span class="n">dbname</span>
    <span class="p">[</span><span class="k">COMMENT</span> <span class="n">database_comment</span><span class="p">]</span>
    <span class="p">[</span><span class="k">LOCATION</span> <span class="n">hdfs_path</span><span class="p">]</span>
    <span class="p">[</span><span class="k">WITH</span> <span class="n">DBPROPERTIES</span> <span class="p">(</span><span class="n">property_name</span><span class="o">=</span><span class="n">property_value</span><span class="p">,</span> <span class="p">...)];</span> 
</code></pre></div><ul>
<li>创建普通库：<code>creat database dbname;</code></li>
<li>检查是否存在：<code>create database if not exists dbname;</code></li>
<li>带注释：<code>create database dbname comment 'create my db named dbname';</code></li>
<li>带属性的库：<code>create database dbname with dbproperties ('a'='aaa','b'='bbb');</code></li>
</ul>
<p><strong>查看库</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">show</span> <span class="n">databases</span><span class="p">;</span>
<span class="k">desc</span>  <span class="k">database</span>  <span class="p">[</span><span class="n">extended</span><span class="p">]</span>  <span class="n">dbname</span><span class="p">;</span>  <span class="c1">-- 显示数据库的详细属性信息 
</span></code></pre></div><p><strong>删除库</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">DROP</span> <span class="p">(</span><span class="k">DATABASE</span><span class="o">|</span><span class="k">SCHEMA</span><span class="p">)</span> <span class="p">[</span><span class="k">IF</span> <span class="k">EXISTS</span><span class="p">]</span> <span class="n">dbname</span> <span class="p">[</span><span class="k">RESTRICT</span><span class="o">|</span><span class="k">CASCADE</span><span class="p">];</span>
<span class="k">drop</span> <span class="k">database</span> <span class="n">dbname</span><span class="p">;</span>
<span class="k">drop</span> <span class="k">database</span> <span class="k">if</span> <span class="k">exists</span> <span class="n">dbname</span><span class="p">;</span> 
</code></pre></div><p>默认情况下，hive 不允许删除包含表的数据库，使用 cascade 关键字:<code>drop database if exists dbname cascade;</code> 默认情况下就是 restrict。</p>
<p><strong>修改库</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">ALTER</span> <span class="p">(</span><span class="k">DATABASE</span><span class="o">|</span><span class="k">SCHEMA</span><span class="p">)</span> <span class="n">dbname</span> <span class="k">SET</span> <span class="n">DBPROPERTIES</span> <span class="p">(</span><span class="n">property_name</span><span class="o">=</span><span class="n">property_value</span><span class="p">,</span> <span class="p">...);</span>   <span class="c1">-- (Note: SCHEMA added in Hive 0.14.0)
</span><span class="c1"></span><span class="k">ALTER</span> <span class="p">(</span><span class="k">DATABASE</span><span class="o">|</span><span class="k">SCHEMA</span><span class="p">)</span> <span class="n">dbname</span> <span class="k">SET</span> <span class="k">OWNER</span> <span class="p">[</span><span class="k">USER</span><span class="o">|</span><span class="k">ROLE</span><span class="p">]</span> <span class="n">user_or_role</span><span class="p">;</span>   <span class="c1">-- (Note: Hive 0.13.0 and later; SCHEMA added in Hive 0.14.0)
</span><span class="c1"></span><span class="k">ALTER</span> <span class="p">(</span><span class="k">DATABASE</span><span class="o">|</span><span class="k">SCHEMA</span><span class="p">)</span> <span class="n">dbname</span> <span class="k">SET</span> <span class="k">LOCATION</span> <span class="n">hdfs_path</span><span class="p">;</span> <span class="c1">-- (Note: Hive 2.2.1, 2.4.0 and later)
</span></code></pre></div><p>更改路径不会将当前数据库目录移动到新目录，只会更改新插入表的默认父路径，即新表会存储到新路径。</p>
<p><strong>使用库</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">use</span> <span class="n">dbname</span><span class="p">;</span>
</code></pre></div><p>通俗理解为进入一个库进行操作，即设置hql语句的当前库。</p>
<h3 id="表操作">表操作</h3>
<p><strong>创建表</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="p">[</span><span class="k">TEMPORARY</span><span class="p">]</span> <span class="p">[</span><span class="k">EXTERNAL</span><span class="p">]</span> <span class="k">TABLE</span> <span class="p">[</span><span class="k">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span><span class="p">]</span> <span class="p">[</span><span class="n">dbname</span><span class="p">.]</span><span class="k">table_name</span>
  <span class="p">[(</span><span class="n">col_name</span> <span class="n">data_type</span> <span class="p">[</span><span class="n">column_constraint_specification</span><span class="p">]</span> <span class="p">[</span><span class="k">COMMENT</span> <span class="n">col_comment</span><span class="p">],</span> 
    <span class="p">...</span>
    <span class="p">[</span><span class="n">constraint_specification</span><span class="p">])]</span>
  <span class="p">[</span><span class="k">COMMENT</span> <span class="n">table_comment</span><span class="p">]</span>
  <span class="p">[</span><span class="n">PARTITIONED</span> <span class="k">BY</span> <span class="p">(</span><span class="n">col_name</span> <span class="n">data_type</span> <span class="p">[</span><span class="k">COMMENT</span> <span class="n">col_comment</span><span class="p">],</span> <span class="p">...)]</span>
  <span class="p">[</span><span class="n">CLUSTERED</span> <span class="k">BY</span> <span class="p">(</span><span class="n">col_name</span><span class="p">,</span> <span class="n">col_name</span><span class="p">,</span> <span class="p">...)</span> <span class="p">[</span><span class="n">SORTED</span> <span class="k">BY</span> <span class="p">(</span><span class="n">col_name</span> <span class="p">[</span><span class="k">ASC</span><span class="o">|</span><span class="k">DESC</span><span class="p">],</span> <span class="p">...)]</span> <span class="k">INTO</span> <span class="n">num_buckets</span> <span class="n">BUCKETS</span><span class="p">]</span>

  <span class="p">[</span><span class="n">SKEWED</span> <span class="k">BY</span> <span class="p">(</span><span class="n">col_name</span><span class="p">,</span> <span class="n">col_name</span><span class="p">,</span> <span class="p">...)</span>                  <span class="c1">-- (Note: Available in Hive 0.10.0 and later)]
</span><span class="c1"></span>     <span class="k">ON</span> <span class="p">((</span><span class="n">col_value</span><span class="p">,</span> <span class="n">col_value</span><span class="p">,</span> <span class="p">...),</span> <span class="p">(</span><span class="n">col_value</span><span class="p">,</span> <span class="n">col_value</span><span class="p">,</span> <span class="p">...),</span> <span class="p">...)</span>
     <span class="p">[</span><span class="n">STORED</span> <span class="k">AS</span> <span class="n">DIRECTORIES</span><span class="p">]</span>

  <span class="p">[</span>
   <span class="p">[</span><span class="k">ROW</span> <span class="n">FORMAT</span> <span class="n">row_format</span><span class="p">]</span> 
   <span class="p">[</span><span class="n">STORED</span> <span class="k">AS</span> <span class="n">file_format</span><span class="p">]</span>
     <span class="o">|</span> <span class="n">STORED</span> <span class="k">BY</span> <span class="s1">&#39;storage.handler.class.name&#39;</span> <span class="p">[</span><span class="k">WITH</span> <span class="n">SERDEPROPERTIES</span> <span class="p">(...)]</span>  <span class="c1">-- (Note: Available in Hive 0.6.0 and later)
</span><span class="c1"></span>  <span class="p">]</span>
  <span class="p">[</span><span class="k">LOCATION</span> <span class="n">hdfs_path</span><span class="p">]</span>
  <span class="p">[</span><span class="n">TBLPROPERTIES</span> <span class="p">(</span><span class="n">property_name</span><span class="o">=</span><span class="n">property_value</span><span class="p">,</span> <span class="p">...)]</span>   <span class="c1">-- (Note: Available in Hive 0.6.0 and later)
</span><span class="c1"></span>  <span class="p">[</span><span class="k">AS</span> <span class="n">select_statement</span><span class="p">];</span>   <span class="c1">-- (Note: Available in Hive 0.5.0 and later; not supported for external tables)
</span><span class="c1"></span>
<span class="k">CREATE</span> <span class="p">[</span><span class="k">TEMPORARY</span><span class="p">]</span> <span class="p">[</span><span class="k">EXTERNAL</span><span class="p">]</span> <span class="k">TABLE</span> <span class="p">[</span><span class="k">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span><span class="p">]</span> <span class="p">[</span><span class="n">db_name</span><span class="p">.]</span><span class="k">table_name</span>
  <span class="k">LIKE</span> <span class="n">existing_table_or_view_name</span>
  <span class="p">[</span><span class="k">LOCATION</span> <span class="n">hdfs_path</span><span class="p">];</span>
</code></pre></div><p><code>EXTERNAL</code>关键字用于创建一个外部表，在建表的同时给出实际数据的 路径（LOCATION），用于数据已经存在于HDFS上，创建外部表仅记录数据所在的路径，不对数据的位置做任何改变。</p>
<p><code>column_constraint_specification</code>即列的约束，包括：<code>PRIMARY KEY|UNIQUE|NOT NULL|DEFAULT [default_value]|CHECK  [check_expression] ENABLE|DISABLE NOVALIDATE RELY/NORELY</code>。</p>
<p><code>constraint_specification</code>对表的约束：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="p">[,</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">col_name</span><span class="p">,</span> <span class="p">...)</span> <span class="n">DISABLE</span> <span class="n">NOVALIDATE</span> <span class="n">RELY</span><span class="o">/</span><span class="n">NORELY</span> <span class="p">]</span>
<span class="p">[,</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">col_name</span><span class="p">,</span> <span class="p">...)</span> <span class="n">DISABLE</span> <span class="n">NOVALIDATE</span> <span class="n">RELY</span><span class="o">/</span><span class="n">NORELY</span> <span class="p">]</span>
<span class="p">[,</span> <span class="k">CONSTRAINT</span> <span class="k">constraint_name</span> <span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">col_name</span><span class="p">,</span> <span class="p">...)</span> <span class="k">REFERENCES</span> <span class="k">table_name</span><span class="p">(</span><span class="n">col_name</span><span class="p">,</span> <span class="p">...)</span> <span class="n">DISABLE</span> <span class="n">NOVALIDATE</span> 
<span class="p">[,</span> <span class="k">CONSTRAINT</span> <span class="k">constraint_name</span> <span class="k">UNIQUE</span> <span class="p">(</span><span class="n">col_name</span><span class="p">,</span> <span class="p">...)</span> <span class="n">DISABLE</span> <span class="n">NOVALIDATE</span> <span class="n">RELY</span><span class="o">/</span><span class="n">NORELY</span> <span class="p">]</span>
<span class="p">[,</span> <span class="k">CONSTRAINT</span> <span class="k">constraint_name</span> <span class="k">CHECK</span> <span class="p">[</span><span class="n">check_expression</span><span class="p">]</span> <span class="n">ENABLE</span><span class="o">|</span><span class="n">DISABLE</span> <span class="n">NOVALIDATE</span> <span class="n">RELY</span><span class="o">/</span><span class="n">NORELY</span> <span class="p">]</span>
</code></pre></div><p><code>COMMENT</code>，为表和字段添加描述。<br>
<code>PARTITIONED BY</code>：设置分区，注意分区字段不能是表中字段。<br>
<code>CLUSTERED BY</code>：设置分桶，SORTED BY可以设置根据字段排序。<br>
<code>ROW FORMAT</code></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">DELIMITED</span> <span class="p">[</span><span class="n">FIELDS</span> <span class="n">TERMINATED</span> <span class="k">BY</span> <span class="nb">char</span> <span class="p">[</span><span class="n">ESCAPED</span> <span class="k">BY</span> <span class="nb">char</span><span class="p">]]</span> <span class="p">[</span><span class="n">COLLECTION</span> <span class="n">ITEMS</span> <span class="n">TERMINATED</span> <span class="k">BY</span> <span class="nb">char</span><span class="p">]</span>
    <span class="p">[</span><span class="k">MAP</span> <span class="n">KEYS</span> <span class="n">TERMINATED</span> <span class="k">BY</span> <span class="nb">char</span><span class="p">]</span> <span class="p">[</span><span class="n">LINES</span> <span class="n">TERMINATED</span> <span class="k">BY</span> <span class="nb">char</span><span class="p">]</span>
    <span class="p">[</span><span class="k">NULL</span> <span class="k">DEFINED</span> <span class="k">AS</span> <span class="nb">char</span><span class="p">]</span>   <span class="c1">-- (Note: Available in Hive 0.13 and later)
</span><span class="c1"></span><span class="o">|</span> <span class="n">SERDE</span> <span class="n">serde_name</span> <span class="p">[</span><span class="k">WITH</span> <span class="n">SERDEPROPERTIES</span> <span class="p">(</span><span class="n">property_name</span><span class="o">=</span><span class="n">property_value</span><span class="p">,</span> <span class="n">property_name</span><span class="o">=</span><span class="n">property_value</span><span class="p">,</span> <span class="p">...)]</span>
</code></pre></div><p>用户在建表的时候可以自定义 SerDe 或者使用自带的 SerDe。如果没有指定 ROW FORMAT 或者 ROW FORMAT DELIMITED，将会使用自带的 SerDe。DELIMITED 指定字段、集合、映射k v的分隔符，以及行结束符。</p>
<p><code>STORED AS</code>，TEXTFILE | SEQUENCEFILE | RCFILE 如果文件数据是纯文本，可以使用 STORED AS TEXTFILE。如果数据需要压缩，使用 STORED AS SEQUENCEFILE。</p>
<ul>
<li>默认格式，数据不做压缩，磁盘开销大，数据解析开销大。 可结合 Gzip、Bzip2 使 用(系统自动检查，执行查询时自动解压)，但使用这种方式，hive 不会对数据进行切分，从而无法对数据进行并行操作。</li>
<li>SequenceFile 是 Hadoop API 提供的一种二进制文件支持，文件内容是以序列化的 kv 对象来组织的，其具有使用方便、可分割、可压缩的特点。 SequenceFile 支持三种压缩 选择：NONE，RECORD，BLOCK。Record 压缩率低，一般建议使用 BLOCK 压缩。</li>
<li>RCFILE 是一种行列存储相结合的存储方式。首先，其将数据按行分块，保证同一个 record 在一个块上，避免读一个记录需要读取多个 block。其次，块数据列式存储，有利 于数据压缩和快速的列存取。相比 TEXTFILE 和 SEQUENCEFILE，RCFILE 由于列式存储方式， 数据加载时性能消耗较大，但是具有较好的压缩比和查询响应。数据仓库的特点是一次 写入、多次读取，因此，整体来看，RCFILE 相比其余两种格式具有较明显的优势。</li>
</ul>
<p><code>LOCATION</code>：指定数据文件存放的 hdfs 目录 。</p>
<p><code>TBLPROPERTIES</code>：设置属性。<br>
<code>AS</code>，通过查询语句创建表。</p>
<p><code>LIKE</code>，允许用户复制现有的表结构，但是不复制数据。示例：<code>create table tableA like tableB</code>（创建一张 tableA 空表复制 tableB 的结构）。</p>
<p>示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">page_view</span><span class="p">(</span>
  <span class="n">viewTime</span> <span class="nb">INT</span><span class="p">,</span> 
  <span class="n">userid</span> <span class="nb">BIGINT</span><span class="p">,</span> 
  <span class="n">page_url</span> <span class="n">STRING</span><span class="p">,</span>
  <span class="n">referrer_url</span> <span class="n">STRING</span><span class="p">,</span> 
  <span class="n">ip</span> <span class="n">STRING</span> <span class="k">COMMENT</span> <span class="s1">&#39;IP Address of the User&#39;</span><span class="p">)</span>  
  <span class="k">COMMENT</span> <span class="s1">&#39;This is the page view table&#39;</span> 
  <span class="n">PARTITIONED</span> <span class="k">BY</span><span class="p">(</span><span class="n">dt</span> <span class="n">STRING</span><span class="p">,</span> <span class="n">country</span> <span class="n">STRING</span><span class="p">)</span> 
  <span class="n">CLUSTERED</span> <span class="k">BY</span><span class="p">(</span><span class="n">userid</span><span class="p">)</span> <span class="n">SORTED</span> <span class="k">BY</span><span class="p">(</span><span class="n">viewTime</span><span class="p">)</span> <span class="k">INTO</span> <span class="mi">31</span> <span class="n">BUCKETS</span> 
  <span class="k">ROW</span> <span class="n">FORMAT</span> <span class="n">DELIMITED</span>  <span class="n">FIELDS</span> <span class="n">TERMINATED</span> <span class="k">BY</span> <span class="s1">&#39;\t&#39;</span> 
  <span class="n">COLLECTION</span> <span class="n">ITEMS</span> <span class="n">TERMINATED</span> <span class="k">BY</span> <span class="s1">&#39;\t&#39;</span>  
  <span class="k">MAP</span> <span class="n">KEYS</span> <span class="n">TERMINATED</span> <span class="k">BY</span> <span class="s1">&#39;\t&#39;</span> 
  <span class="n">LINES</span> <span class="n">TERMINATED</span> <span class="k">BY</span> <span class="s1">&#39;\n&#39;</span> 
  <span class="n">STORED</span> <span class="k">AS</span> <span class="n">TEXTFILE</span>  <span class="k">LOCATION</span> <span class="s1">&#39;/myhive&#39;</span> 
</code></pre></div><p>使用<code>desc formatted page_view;</code>查看表结构。</p>
<p>Hive 使用一个 Inputformat 对象将输入流分割成记录；使用一个 Outputformat 对象将记录格 式化为输出流，使用序列化/反序列化器 SerDe 做记录的解析（记录和列的转换）。 它们的默认值分别是： Inputformat：org.apache.hadoop.mapred.TextInputFormat；Outputformat：org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat；SerDe：org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe。</p>
<p><strong>常用修改表</strong><br>
重命名表</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">table_name</span> <span class="k">RENAME</span> <span class="k">TO</span> <span class="n">new_table_name</span><span class="p">;</span>
</code></pre></div><p>增加/替换列/删除/改变/</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">name</span> <span class="k">ADD</span><span class="o">|</span><span class="k">REPLACE</span> <span class="n">COLUMNS</span> <span class="p">(</span><span class="n">col_spec</span><span class="p">[,</span> <span class="n">col_spec</span> <span class="p">...])</span> 
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">name</span> <span class="k">DROP</span> <span class="p">[</span><span class="k">COLUMN</span><span class="p">]</span> <span class="k">column_name</span> 
<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">name</span> <span class="n">CHANGE</span> <span class="n">c_name</span> <span class="n">new_name</span> <span class="n">new_type</span> <span class="p">[</span><span class="k">FIRST</span><span class="o">|</span><span class="k">AFTER</span> <span class="n">c_name</span><span class="p">]</span> 
</code></pre></div><p>ADD 新增一字段，字段位置在所有列后面(partition 列前)，REPLACE 则是替换表中所有字段。</p>
<p>增加/删除分区</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">table_name</span> <span class="k">ADD</span> <span class="p">[</span><span class="k">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span><span class="p">]</span> <span class="n">partition_spec</span> <span class="p">[</span> <span class="k">LOCATION</span> <span class="s1">&#39;location1&#39;</span> <span class="p">]</span> <span class="n">partition_spec</span> <span class="p">[</span> <span class="k">LOCATION</span> <span class="s1">&#39;location2&#39;</span> <span class="p">]</span> <span class="p">...</span> 
 
<span class="n">partition_spec</span> <span class="p">:</span> <span class="n">PARTITION</span> <span class="p">(</span><span class="n">partition_col</span> <span class="o">=</span> <span class="n">partition_col_value</span><span class="p">,</span> <span class="n">partition_col</span> <span class="o">=</span> <span class="n">partiton_col_value</span><span class="p">,</span> <span class="p">...)</span> 
<span class="c1">--删除  
</span><span class="c1"></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">table_name</span> <span class="k">DROP</span> <span class="n">partition_spec</span><span class="p">,</span> <span class="n">partition_spec</span><span class="p">,...</span> 
</code></pre></div><p><strong>删除表</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">DROP</span> <span class="k">TABLE</span> <span class="p">[</span><span class="k">IF</span> <span class="k">EXISTS</span><span class="p">]</span> <span class="k">table_name</span><span class="p">;</span> 
</code></pre></div><h3 id="showdesc">show/desc</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SHOW</span> <span class="p">(</span><span class="n">DATABASES</span><span class="o">|</span><span class="n">SCHEMAvS</span><span class="p">)</span> <span class="p">[</span><span class="k">LIKE</span> <span class="s1">&#39;identifier_with_wildcards&#39;</span><span class="p">];</span>  <span class="c1">--查看库
</span><span class="c1"></span><span class="k">SHOW</span> <span class="n">TABLES</span> <span class="p">[</span><span class="k">IN</span> <span class="n">database_name</span><span class="p">]</span> <span class="p">[</span><span class="s1">&#39;identifier_with_wildcards&#39;</span><span class="p">];</span> <span class="c1">--查看表
</span><span class="c1"></span><span class="k">SHOW</span> <span class="n">VIEWS</span> <span class="p">[</span><span class="k">IN</span><span class="o">/</span><span class="k">FROM</span> <span class="n">database_name</span><span class="p">]</span> <span class="p">[</span><span class="k">LIKE</span> <span class="s1">&#39;pattern_with_wildcards&#39;</span><span class="p">];</span> <span class="c1">--查看视图
</span><span class="c1"></span><span class="k">SHOW</span> <span class="n">PARTITIONS</span> <span class="k">table_name</span><span class="p">;</span> <span class="c1">--查看分区
</span><span class="c1"></span><span class="k">SHOW</span> <span class="n">PARTITIONS</span> <span class="k">table_name</span> <span class="n">PARTITION</span><span class="p">(</span><span class="n">city</span><span class="o">=</span><span class="s1">&#39;beijing&#39;</span><span class="p">)</span> <span class="c1">--查看 hive 表的分区
</span><span class="c1"></span><span class="k">SHOW</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="p">([</span><span class="n">db_name</span><span class="p">.]</span><span class="k">table_name</span><span class="o">|</span><span class="n">view_name</span><span class="p">);</span>  <span class="c1">--查看创建表语句
</span><span class="c1"></span><span class="k">SHOW</span> <span class="n">COLUMNS</span> <span class="p">(</span><span class="k">FROM</span><span class="o">|</span><span class="k">IN</span><span class="p">)</span> <span class="k">table_name</span> <span class="p">[(</span><span class="k">FROM</span><span class="o">|</span><span class="k">IN</span><span class="p">)</span> <span class="n">db_name</span><span class="p">];</span> <span class="c1">--查看列
</span><span class="c1"></span><span class="k">SHOW</span> <span class="n">FUNCTIONS</span><span class="p">;</span> <span class="c1">--查看 hive 函数列表 
</span><span class="c1"></span>
<span class="c1">--查看表的详细信息（元数据信息）
</span><span class="c1"></span><span class="k">desc</span> <span class="k">table_name</span><span class="p">;</span> 
<span class="k">desc</span> <span class="n">extended</span> <span class="k">table_name</span><span class="p">;</span> 
<span class="k">desc</span> <span class="n">formatted</span> <span class="k">table_name</span><span class="p">;</span> 

<span class="c1">--查看数据库的详细属性信息 
</span><span class="c1"></span><span class="k">desc</span> <span class="k">database</span> <span class="n">db_name</span><span class="p">;</span> 
<span class="k">desc</span> <span class="k">database</span> <span class="n">extended</span> <span class="n">db_name</span><span class="p">;</span> 

<span class="c1">--清空数据表
</span><span class="c1"></span><span class="k">truncate</span> <span class="k">table</span> <span class="k">table_name</span><span class="p">;</span>
</code></pre></div><h2 id="dml-操作">DML 操作</h2>
<h3 id="load">Load</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">LOAD</span> <span class="k">DATA</span> <span class="p">[</span><span class="k">LOCAL</span><span class="p">]</span> <span class="n">INPATH</span> <span class="s1">&#39;filepath&#39;</span> <span class="p">[</span><span class="n">OVERWRITE</span><span class="p">]</span> <span class="k">INTO</span> <span class="k">TABLE</span> <span class="n">tablename</span> <span class="p">[</span><span class="n">PARTITION</span> <span class="p">(</span><span class="n">partcol1</span><span class="o">=</span><span class="n">val1</span><span class="p">,</span> <span class="n">partcol2</span><span class="o">=</span><span class="n">val2</span> <span class="p">...)]</span>
</code></pre></div><ul>
<li>Load 操作只是单纯的复制（local）/移动（hdfs）操作，将数据文件移动到 Hive 表对应的 位置。</li>
<li><code>LOCAL</code>，load 命令会去查找本地文件系统中的 filepath。 如果没有指定 LOCAL 关键字，则根据 inpath 中的 uri 查找文件。uri 是指 hdfs 上的路径。</li>
<li>filepath： 可以是相对路径、绝对路径、完整 URI。注意：inpath 子句中的文件路径下，不能再有文件夹。</li>
<li><code>OVERWRITE</code> 如果使用了 OVERWRITE 关键字，则目标表（或者分区）中的内容会被删除，然后再将 filepath 指向的文件/目录中的内容添加到表/分区中。  如果目标表（分区）已经有一个文件，并且文件名和 filepath 中的文件名冲突，那么现 有的文件会被新文件所替代。</li>
</ul>
<h3 id="insert">Insert</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">NSERT</span> <span class="k">INTO</span> <span class="k">TABLE</span> <span class="n">tablename</span> <span class="p">[</span><span class="n">PARTITION</span> <span class="p">(</span><span class="n">partcol1</span><span class="p">[</span><span class="o">=</span><span class="n">val1</span><span class="p">],</span> <span class="n">partcol2</span><span class="p">[</span><span class="o">=</span><span class="n">val2</span><span class="p">]</span> <span class="p">...)]</span> <span class="k">VALUES</span> <span class="p">(</span><span class="n">values_row</span><span class="p">)</span> <span class="p">[,</span> <span class="p">(</span><span class="n">values_row</span><span class="p">)</span> <span class="p">...];</span>
</code></pre></div><p>每个列必须给出值，可用null标识空。INSERT INTO&hellip;VALUES不支持复杂数据类型。</p>
<p><strong>利用查询语句将结果导入新表</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">INSERT</span> <span class="n">OVERWRITE</span> <span class="k">TABLE</span> <span class="n">tablename1</span> <span class="p">[</span><span class="n">PARTITION</span> <span class="p">(</span><span class="n">partcol1</span><span class="o">=</span><span class="n">val1</span><span class="p">,</span> <span class="n">partcol2</span><span class="o">=</span><span class="n">val2</span> <span class="p">...)</span> <span class="p">[</span><span class="k">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span><span class="p">]]</span> <span class="n">select_statement1</span> <span class="k">FROM</span> <span class="n">from_statement</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="k">TABLE</span> <span class="n">tablename1</span> <span class="p">[</span><span class="n">PARTITION</span> <span class="p">(</span><span class="n">partcol1</span><span class="o">=</span><span class="n">val1</span><span class="p">,</span> <span class="n">partcol2</span><span class="o">=</span><span class="n">val2</span> <span class="p">...)]</span> <span class="n">select_statement1</span> <span class="k">FROM</span> <span class="n">from_statement</span><span class="p">;</span>
</code></pre></div><p>OVERWRITE会覆盖表中所有的原始数据，INTO为追加。<br>
<em>多重插入</em></p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">FROM</span> <span class="n">from_statement</span>
<span class="k">INSERT</span> <span class="n">OVERWRITE</span><span class="o">/</span><span class="k">INTO</span> <span class="k">TABLE</span> <span class="n">tablename1</span> <span class="p">[</span><span class="n">PARTITION</span> <span class="p">(</span><span class="n">partcol1</span><span class="o">=</span><span class="n">val1</span><span class="p">,</span> <span class="n">partcol2</span><span class="o">=</span><span class="n">val2</span> <span class="p">...)</span> <span class="p">[</span><span class="k">IF</span> <span class="k">NOT</span> <span class="n">EXISTS只有OVERWRITE时可选</span><span class="p">]]</span> <span class="n">select_statement1</span>
<span class="p">[</span><span class="k">INSERT</span> <span class="n">OVERWRITE</span><span class="o">/</span><span class="k">INTO</span> <span class="k">TABLE</span> <span class="n">tablename2</span> <span class="p">[</span><span class="n">PARTITION</span> <span class="p">...</span> <span class="p">[</span><span class="k">IF</span> <span class="k">NOT</span> <span class="n">EXISTS只有OVERWRITE时可选</span><span class="p">]]</span> <span class="n">select_statement2</span><span class="p">];</span>
</code></pre></div><p>从from_statement（如一张表）中，按不同的查询结果插入到不同的Hive表中，如：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">from</span> <span class="n">studentss</span>    
<span class="k">insert</span> <span class="k">into</span> <span class="k">table</span> <span class="n">student_ptn</span> <span class="n">partition</span><span class="p">(</span><span class="n">city</span><span class="o">=</span><span class="s1">&#39;sa&#39;</span><span class="p">)</span> <span class="k">select</span> <span class="n">id</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">sex</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="n">department</span> <span class="k">where</span> <span class="n">department</span><span class="o">=</span><span class="s1">&#39;MA&#39;</span> 
<span class="k">insert</span> <span class="k">into</span> <span class="k">table</span> <span class="n">student_ptn</span> <span class="n">partition</span><span class="p">(</span><span class="n">city</span><span class="o">=</span><span class="s1">&#39;sb&#39;</span><span class="p">)</span> <span class="k">select</span> <span class="n">id</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">sex</span><span class="p">,</span><span class="n">age</span><span class="p">,</span><span class="n">department</span><span class="p">;</span> 
</code></pre></div><p><strong>分区插入</strong><br>
分区插入有两种，一种是静态分区，另一种是动态分区。如果混合使用静态分区和动态分区， 则静态分区必须出现在动态分区之前。</p>
<p><code>静态分区</code>： 1、创建静态分区表 2、从查询结果中导入数据 3、查看插入结果<br>
<code>动态分区</code>： 静态分区需要写SQL来创建，Hive 提供动态分 区功能，可以基于查询参数推断出需要创建的分区名称。</p>
<p>1、创建分区表，和创建静态分区表是一样的 
2、参数设置</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">hive</span><span class="o">&gt;</span> <span class="k">set</span> <span class="n">hive</span><span class="p">.</span><span class="k">exec</span><span class="p">.</span><span class="k">dynamic</span><span class="p">.</span><span class="n">partition</span><span class="o">=</span><span class="k">true</span><span class="p">;</span>
<span class="n">hive</span><span class="o">&gt;</span> <span class="k">set</span> <span class="n">hive</span><span class="p">.</span><span class="k">exec</span><span class="p">.</span><span class="k">dynamic</span><span class="p">.</span><span class="n">partition</span><span class="p">.</span><span class="k">mode</span><span class="o">=</span><span class="n">nonstrict</span><span class="p">;</span>
</code></pre></div><p>动态分区默认情况下是没有开启的。开启后，默认是以”严格“模式执行的，在这种模式下要求至少有一列分区字段是静态的。这有助于阻止因设计错误导致查询产生 大量的分区。但是此处我们不需要静态分区字段，估将其设为 nonstrict。一些相关参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">set</span> <span class="n">hive</span><span class="p">.</span><span class="k">exec</span><span class="p">.</span><span class="k">max</span><span class="p">.</span><span class="k">dynamic</span><span class="p">.</span><span class="n">partitions</span><span class="p">.</span><span class="n">pernode</span><span class="o">=</span><span class="mi">100</span><span class="p">;</span>    <span class="o">//</span><span class="err">每个节点生成动态分区最大个数</span>  
<span class="k">set</span> <span class="n">hive</span><span class="p">.</span><span class="k">exec</span><span class="p">.</span><span class="k">max</span><span class="p">.</span><span class="k">dynamic</span><span class="p">.</span><span class="n">partitions</span><span class="o">=</span><span class="mi">1000</span><span class="p">;</span>   <span class="o">//</span><span class="err">生成动态分区最大个数，如果自</span> <span class="err">动分区数大于这个参数，将会报错</span>  
<span class="k">set</span> <span class="n">hive</span><span class="p">.</span><span class="k">exec</span><span class="p">.</span><span class="k">max</span><span class="p">.</span><span class="n">created</span><span class="p">.</span><span class="n">files</span><span class="err">＝</span><span class="mi">150000</span><span class="p">;</span>   <span class="o">//</span><span class="err">一个任务最多可以创建的文件数目</span> 
<span class="k">set</span> <span class="n">dfs</span><span class="p">.</span><span class="n">datanode</span><span class="p">.</span><span class="k">max</span><span class="p">.</span><span class="n">xcievers</span><span class="o">=</span><span class="mi">4096</span><span class="p">;</span>      <span class="o">//</span><span class="err">限定一次最多打开的文件数</span>
<span class="k">set</span> <span class="n">hive</span><span class="p">.</span><span class="n">error</span><span class="p">.</span><span class="k">on</span><span class="p">.</span><span class="n">empty</span><span class="p">.</span><span class="n">partition</span><span class="o">=</span><span class="k">false</span><span class="p">;</span>    <span class="o">//</span><span class="err">表示当有空分区产生时，是否抛出异常</span> 
</code></pre></div><p>如果以上参数被更改过，还原使用 reset 命令执行一次即可。。 
3、动态数据插入</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">insert</span> <span class="k">into</span> <span class="k">table</span> <span class="n">test2</span> <span class="n">partition</span> <span class="p">(</span><span class="n">age</span><span class="p">)</span> 
<span class="k">select</span> <span class="n">name</span><span class="p">,</span><span class="n">address</span><span class="p">,</span><span class="n">school</span><span class="p">,</span><span class="n">age</span> <span class="k">from</span> <span class="n">students</span><span class="p">;</span> 
<span class="k">insert</span> <span class="k">into</span> <span class="k">table</span> <span class="n">student_ptn2</span> <span class="n">partition</span><span class="p">(</span><span class="n">city</span><span class="o">=</span><span class="s1">&#39;sa&#39;</span><span class="p">,</span><span class="n">zipcode</span><span class="p">)</span> 
<span class="k">select</span> <span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">sex</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">department</span><span class="p">,</span> <span class="n">department</span> <span class="k">as</span> <span class="n">zipcode</span> <span class="k">from</span> <span class="n">studentss</span><span class="p">;</span> 
</code></pre></div><p>查询语句 select 查询出来的 age 字段必须放在最后，和分区字段对应，不然结果会出错。</p>
<p>4、查看插入结果<code>select * from student_ptn2 where city=’sa’ and zipcode=’MA’; </code></p>
<p><strong>CTAS（create table … as select …）</strong><br>
Hive 的查询输出结果直接保存在一个新的表中是非常方便的，我们称这种情况为 CTAS，如</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">mytest</span> <span class="k">AS</span> <span class="k">SELECT</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span> <span class="k">FROM</span> <span class="n">test</span><span class="p">;</span> 
</code></pre></div><p>CTAS 操作是原子的，因此如果 select 查询由于某种原因而失败，新表不会创建。</p>
<h3 id="insert-导出数据">Insert 导出数据</h3>
<p>单导出</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">INSERT</span> <span class="n">OVERWRITE</span> <span class="p">[</span><span class="k">LOCAL</span><span class="p">]</span> <span class="n">DIRECTORY</span> <span class="n">directory1</span> <span class="n">select_statement</span> 
</code></pre></div><p>多导出</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">FROM</span> <span class="n">from_statement</span> <span class="k">INSERT</span> <span class="n">OVERWRITE</span> <span class="p">[</span><span class="k">LOCAL</span><span class="p">]</span> <span class="n">DIRECTORY</span> <span class="n">directory1</span> <span class="n">select_statement1</span> 
<span class="p">[</span><span class="k">INSERT</span> <span class="n">OVERWRITE</span> <span class="p">[</span><span class="k">LOCAL</span><span class="p">]</span> <span class="n">DIRECTORY</span> <span class="n">directory2</span> <span class="n">select_statement2</span><span class="p">]</span> <span class="p">...</span> 
</code></pre></div><h3 id="select">Select</h3>
<p>Hive 中的 SELECT 基础语法和标准 SQL 语法基本一致，</p>
<ul>
<li>支持 WHERE、DISTINCT、GROUP BY、 ORDER BY、HAVING、LIMIT、子查询等。</li>
<li>支持union all、join（left、right、full join）、 like、where、各种聚合函数、 支持 json 解析。</li>
<li>UDF（User Defined Function）/ UDAF/UDTF</li>
<li>不支持 update 和 delete</li>
<li>hive 虽然支持 in/exists（老版本是不支持），但是 hive 推荐使用 semi join 的方式来代 替实现，而且效率更高。</li>
<li>支持 case … when …</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="p">[</span><span class="k">WITH</span> <span class="n">CommonTableExpression</span> <span class="p">(,</span> <span class="n">CommonTableExpression</span><span class="p">)</span><span class="o">*</span><span class="p">]</span>    <span class="p">(</span><span class="n">Note</span><span class="p">:</span> <span class="k">Only</span> <span class="n">available</span> <span class="n">starting</span> <span class="k">with</span> <span class="n">Hive</span> <span class="mi">0</span><span class="p">.</span><span class="mi">13</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
<span class="k">SELECT</span> <span class="p">[</span><span class="k">ALL</span> <span class="o">|</span> <span class="k">DISTINCT</span><span class="p">]</span> <span class="n">select_expr</span><span class="p">,</span> <span class="n">select_expr</span><span class="p">,</span> <span class="p">...</span>
  <span class="k">FROM</span> <span class="n">table_reference</span>
  <span class="p">[</span><span class="k">WHERE</span> <span class="n">where_condition</span><span class="p">]</span>
  <span class="p">[</span><span class="k">GROUP</span> <span class="k">BY</span> <span class="n">col_list</span><span class="p">]</span>
  <span class="p">[</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">col_list</span><span class="p">]</span>
  <span class="p">[</span><span class="k">CLUSTER</span> <span class="k">BY</span> <span class="n">col_list</span>
    <span class="o">|</span> <span class="p">[</span><span class="n">DISTRIBUTE</span> <span class="k">BY</span> <span class="n">col_list</span><span class="p">]</span> <span class="p">[</span><span class="n">SORT</span> <span class="k">BY</span> <span class="n">col_list</span><span class="p">]</span>
  <span class="p">]</span>
 <span class="p">[</span><span class="k">LIMIT</span> <span class="p">[</span><span class="k">offset</span><span class="p">,]</span> <span class="k">rows</span><span class="p">]</span>
</code></pre></div><p><code>ORDER BY(字段) 全局排序</code>，此时只能有一个 reducer，会导致当输入规模较大时，需要较长的计算时间。<br>
<code>SORT BY(字段) 局部排序</code>，其在数据进入 reducer 前完成排序。因此，如果用 sort by 进行排序，并且设置 mapred.reduce.tasks&gt;1，则 sort by 只保证每个 reducer 的输出有序，不保证全局有序。 如果要对所有处理结果进行综合排序，而且数据量又非常大，此时不适用 order by 进行全数据排序，适用 sort by 对数据进行局部排序，然后再对所有的局部排序结果做一个归并排序。<br>
<code>DISTRIBUTE BY(字段)</code> 根据指定的字段将数据分到不同的 reducer，且分发算法是 hash 散列。<br>
<code>CLUSTER BY(字段)</code> 除了具有 Distribute by 的功能外，还会对该字段进行排序。</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">set</span> <span class="n">hive</span><span class="p">.</span><span class="n">enforce</span><span class="p">.</span><span class="n">bucketing</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>  <span class="c1">--开启分桶
</span><span class="c1"></span><span class="k">set</span> <span class="n">mapreduce</span><span class="p">.</span><span class="n">job</span><span class="p">.</span><span class="n">reduces</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>  <span class="c1">--reduce task 数量也是分桶数
</span></code></pre></div><p>是否会转化为MapReduce程序：</p>
<ul>
<li>select * from student; // 简单读取表中文件数据时不会</li>
<li>where 过滤条件中只是分区字段时不会转换成 MapReduce</li>
<li>set hive.exec.mode.local.auto=true;  // hive 会尝试使用本地模式执行</li>
</ul>
<p>否则，其他情况都会被转换成 MapReduce 程序执行。</p>
<h3 id="join">Join</h3>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="n">join_table</span><span class="p">:</span>
    <span class="n">table_reference</span> <span class="p">[</span><span class="k">INNER</span><span class="p">]</span> <span class="k">JOIN</span> <span class="n">table_factor</span> <span class="p">[</span><span class="n">join_condition</span><span class="p">]</span>
  <span class="o">|</span> <span class="n">table_reference</span> <span class="err">{</span><span class="k">LEFT</span><span class="o">|</span><span class="k">RIGHT</span><span class="o">|</span><span class="k">FULL</span><span class="err">}</span> <span class="p">[</span><span class="k">OUTER</span><span class="p">]</span> <span class="k">JOIN</span> <span class="n">table_reference</span> <span class="n">join_condition</span>
  <span class="o">|</span> <span class="n">table_reference</span> <span class="k">LEFT</span> <span class="n">SEMI</span> <span class="k">JOIN</span> <span class="n">table_reference</span> <span class="n">join_condition</span>
  <span class="o">|</span> <span class="n">table_reference</span> <span class="k">CROSS</span> <span class="k">JOIN</span> <span class="n">table_reference</span> <span class="p">[</span><span class="n">join_condition</span><span class="p">]</span> <span class="p">(</span><span class="k">as</span> <span class="k">of</span> <span class="n">Hive</span> <span class="mi">0</span><span class="p">.</span><span class="mi">10</span><span class="p">)</span>

<span class="n">join_condition</span><span class="p">:</span> <span class="k">ON</span> <span class="n">expression</span>
</code></pre></div><p>Hive 支持等值连接（equality join）、外连接（outer join）和（left/right join）。 Hive 不支持非 等值的连接，因为非等值连接非常难转化到 map/reduce 任务。 Hive 支持多于 2 个表的连接。</p>
<p>1、 只支持等值链接，支持 and，不支持 or</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">a</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">a</span> <span class="k">JOIN</span> <span class="n">b</span> <span class="k">ON</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
<span class="k">SELECT</span> <span class="n">a</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">a</span> <span class="k">JOIN</span> <span class="n">b</span> <span class="k">ON</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">id</span> <span class="k">AND</span> <span class="n">a</span><span class="p">.</span><span class="n">department</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">department</span><span class="p">);</span>
</code></pre></div><p>2、 可以 join 多于 2 个表</p>
<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span> <span class="n">a</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="k">c</span><span class="p">.</span><span class="n">val</span> <span class="k">FROM</span> <span class="n">a</span> <span class="k">JOIN</span> <span class="n">b</span> <span class="k">ON</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="k">key</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">key1</span><span class="p">)</span> <span class="k">JOIN</span> <span class="k">c</span> <span class="k">ON</span> <span class="p">(</span><span class="k">c</span><span class="p">.</span><span class="k">key</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">key2</span><span class="p">);</span>
</code></pre></div><p>应该把最大的 那个表写在最后（否则会因为缓存浪费大量内存）。</p>
<p>HiveJoin 分三种：inner join, outer join, semi join 其中：outer join 包括 left join，right join 和 full outer join,主要用来处理 join 中空记录的 情况。</p>
<ul>
<li>inner join内连接，将符合两边连接条件的数据查询出来，其他的不要。</li>
<li>left join左连接，等同于 left outer join，以左表数据为匹配标准，从右表中选出符合条件的join，左表无匹配的join过来null，因此返回的数据条数与左表相同。</li>
<li>right join右连接，与left join左右相反。</li>
<li>left semi join左半连接，hive低版本不支持 in/exists 操作（1.2.1 版本的 hive 支持 in 的操作），所以用该操作实现，并且是 in/exists 的高效实现），即左表中符合连接条件的数据。</li>
<li>full outer join完全外链接，左右表的数据全要，连接不上的连接null。</li>
</ul>
</article><section class="article labels"><a class="category" href=/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/>大数据</a><a class="tag" href=/tags/hive/>Hive</a></section></div><section class="article navigation"><p><a class="link" href="/post/hive3/"><span class="li">&larr;</span>数据仓库Hive_高级操作</a></p><p><a class="link" href="/post/%E5%AE%89%E8%A3%85mysql/"><span class="li">&rarr;</span>安装MySQL</a></p></section></div><section id="footer" class="footer"><div class="footer-wrap">
    <p class="copyright">©2020 Notepadium.</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/&#43;DiW/UqRcLbRjq" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l&#43;B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd&#43;qj&#43;o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
            onload="renderMathInElement(document.body);"></script></div>
</body>

</html>